<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小胖轩</title>
    <description>编码生涯的点点滴滴</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 18 May 2019 15:40:53 +0800</pubDate>
    <lastBuildDate>Sat, 18 May 2019 15:40:53 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Android开发及使用技巧</title>
        <description>&lt;h3 id=&quot;1-查看wifi密码&quot;&gt;1. 查看wifi密码&lt;/h3&gt;

&lt;p&gt;查询连接的wifi密码，没问题，前提是手机已经root了，可以查看系统文件，android的wifi密码明文保存在一下文件中，使用root explorer查看即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/data/misc/wifi/wpa_supplicant.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-查看activity堆栈情况&quot;&gt;2. 查看activity堆栈情况&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;adb shell dumpsys activity ---------------查看ActvityManagerService 所有信息
adb shell dumpsys activity activities ----------查看Activity组件信息
adb shell dumpsys activity services -----------查看Service组件信息
adb shell dumpsys activity providers ----------产看ContentProvider组件信息
adb shell dumpsys activity broadcasts --------查看BraodcastReceiver信息
adb shell dumpsys activity intents --------------查看Intent信息
adb shell dumpsys activity processes ---------查看进程信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-查看apk中的androidmanifestxml文件&quot;&gt;3. 查看apk中的AndroidManifest.xml文件&lt;/h3&gt;

&lt;p&gt;可以使用apktool对apk进行反编译，不过现在很多的apk都进行了加固，可以防止apktool进行反编译，我们可以使用google提供的aapt(Android Asset Packaging Tool)进行查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aapt dump xmltree target.apk AndroidManifest.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中target.apk为需要查看AndroidManifest.xml的apk包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4-查看android的log&quot;&gt;4. 查看android的log&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;adb logcat

&quot;-s&quot;选项 : 设置输出日志的标签, 只显示该标签的日志;

&quot;-f&quot;选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;

&quot;-r&quot;选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;

&quot;-n&quot;选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;

&quot;-v&quot;选项 : 设置日志的输出格式, 注意只能设置一项;

&quot;-c&quot;选项 : 清空所有的日志缓存信息;

&quot;-d&quot;选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;

&quot;-t&quot;选项 : 输出最近的几行日志, 输出完退出, 不阻塞;

&quot;-g&quot;选项 : 查看日志缓冲区信息;

&quot;-b&quot;选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;

&quot;-B&quot;选项 : 以二进制形式输出日志;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;持续更新…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 28 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/28/android-trick/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/28/android-trick/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>获取所有分组中某列最大的行</title>
        <description>&lt;p&gt;&lt;strong&gt;怎么获取所有分组中某列最大的行？&lt;/strong&gt;下面用一个例子来说明下：&lt;/p&gt;

&lt;p&gt;一共公司有若干员工，每个员工有各自的id, group_id(部门), salary(工资).现在的问题转变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;求公司各部门最高工资的员工
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先明确一个问题，一个部门的若干个员工可能同时拥有最高的工资，需要都列举出来。&lt;/p&gt;

&lt;p&gt;看一下员工的数据库表结构(只包含有用的列):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Field&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Null&lt;/th&gt;
      &lt;th&gt;Key&lt;/th&gt;
      &lt;th&gt;Default&lt;/th&gt;
      &lt;th&gt;Extra&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;id&lt;/td&gt;
      &lt;td&gt;int(11)&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;PRI&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;group_id&lt;/td&gt;
      &lt;td&gt;int(11)&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;salary&lt;/td&gt;
      &lt;td&gt;int(11)&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;添加的测试数据如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;group_id&lt;/th&gt;
      &lt;th&gt;salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们需要做的步骤如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;获取各个部门最高的工资&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;查找各个部门工资等于最高工资的员工&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;获取各个部门最高的工资&quot;&gt;获取各个部门最高的工资&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;select group_id, max(salary) as max_salary from employee group by group_id ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后的结果:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;group_id&lt;/th&gt;
      &lt;th&gt;max_salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;查找各个部门工资等于最高工资的员工&quot;&gt;查找各个部门工资等于最高工资的员工&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;select a.id, a.group_id, a.salary from employee as a, b where a.group_id=b.group_id and a.salary=b.max_salary ;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;假设第一执行后的数据存在表b中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样就得到了最终的结果:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;group_id&lt;/th&gt;
      &lt;th&gt;salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;300&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们可以简单的将&lt;strong&gt;获取各个部门最高的工资&lt;/strong&gt;的代码替换b即可，组合后的语句如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select a.id, a.group_id, a.salary from employee as a, (select group_id, max(salary) as max_salary from employee group by group_id) as b where a.group_id=b.group_id and a.salary=b.max_salary ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后的结果相同。&lt;/p&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;我们首先按照部门进行分组，获取每组最大的工资(表b); 之后将表a(原表)与表b做一下笛卡尔积，筛选出我们需要的数据即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 20 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/20/get-max-from-every-group/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/20/get-max-from-every-group/</guid>
        
        <category>database</category>
        
        
      </item>
    
      <item>
        <title>Android WebView页面加载优化</title>
        <description>&lt;p&gt;目前webapp越来越多，体验也越来越好，为了能够更好的使用WebView展示出流畅的的页面，可以从以下几点做优化：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WebView缓存&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;资源文件本地存储&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;减少耗时操作&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;客户端UI优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能有人会说了，为什么不做成native的呢，这样就不用那么的麻烦了。如果我需要加载的内容都是静态的，当然做成native的是最好的，为什么我们要使用WebView呢，因为它可以加载一些容易改变的内容，同时也方便制作多平台应用。&lt;/p&gt;

&lt;p&gt;WebView可以优化的哪些地方呢?&lt;/p&gt;

&lt;h3 id=&quot;webview缓存&quot;&gt;WebView缓存&lt;/h3&gt;

&lt;p&gt;开启WebView的缓存功能可以减少对服务器资源的请求，一般使用默认缓存策略就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//设置 缓存模式 
webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT);  
// 开启 DOM storage API 功能 
webView.getSettings().setDomStorageEnabled(true); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;资源文件本地存储&quot;&gt;资源文件本地存储&lt;/h3&gt;

&lt;p&gt;资源等文件(不需要更新)本地存储，在需要的时候直接从本地获取。哪些资源需要我们去存储在本地呢，当然是一些不会被更新的资源，例如图片文件，js文件，css文件，替换的方法也很简单，重写WebView的方法即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
      try {
	      if (url.endsWith(&quot;icon.png&quot;)) {
	          InputStream is = appRm.getInputStream(R.drawable.icon);
	          WebResourceResponse response = new WebResourceResponse(&quot;image/png&quot;,
	            &quot;utf-8&quot;, is);
	          return response;
	      } else if (url.endsWith(&quot;jquery.min.js&quot;)) {
	          InputStream is = appRm.getInputStream(R.raw.jquery_min_js);
	          WebResourceResponse response = new WebResourceResponse(&quot;text/javascript&quot;,
	            &quot;utf-8&quot;, is);
	          return response;
	      }
	      } catch (IOException e) {
	     		 e.printStackTrace();
	      }
	      return super.shouldInterceptRequest(view, url);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;appRm为app资源管理器，读取drawable，assets，raw下的资源，都是android系统的一些很简单的函数调用。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;getInputStream的参数代表资源具体位置&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;WebResourceResponse后的资源类型需要写正确&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;有些时候我们会为我们的网站加入一些统计代码，这些也可以精简掉(自己使用的CNZZ的大概占的有10k左右)，可以使用Charles对客户端进行抓包查看。&lt;/p&gt;

&lt;h3 id=&quot;减少耗时操作&quot;&gt;减少耗时操作&lt;/h3&gt;

&lt;p&gt;准确的说，是减少同步操作的操作时间，尽量使用异步操作替代同步操作。如果服务端存在读取数据库和计算耗时的操作，尽量使用异步(ajax)进行操作，把原本的时间花在异步操作上。&lt;/p&gt;

&lt;p&gt;举个例子，A页面到B页面，A页面实现登录功能，B页面展示主功能页面，如果让B页面去进行用户登录信息验证的话，B页面加载时间会加长(数据库查询等操作)，同时客户端可能需要提供一个等待框(或进度条等)给用户，那看看在A页面使用异步操作的优势吧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以提供统一的js等待框，多平台保持一致性，减少客户端代码工作量。&lt;/li&gt;
  &lt;li&gt;加载页面的时间变短。B页面由于减少了耗时的操作，加载时间变短，用户等待时间也变短。&lt;/li&gt;
  &lt;li&gt;可以方便加入一些验证后的控制逻辑，不需要进行页面跳转。A页面可以根据异步操作进行结果判断，做出相应的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;客户端ui优化&quot;&gt;客户端UI优化&lt;/h3&gt;

&lt;p&gt;怎么让用户看不到WebView加载前的白色页面呢？首次加载后页面的跳转可以用上面的步骤进行优化，可以提供给用户一个很好的体验，那加载的第一页呢？我们需要WebView预加载页面，这个该怎么做到的呢？下面提供两种方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ViewPager，将欢迎页面与WebView页面一起放进ViewPager中，设置预加载页面个数，使WebView所在页面可以预加载，在加载完毕的时候切换到WebView所在页面。&lt;/li&gt;
  &lt;li&gt;FrameLayout，将欢迎页面与WebView页面的布局合在一起，显示在一个页面内，起始隐藏WebView布局，待WebView加载完毕，隐藏欢迎布局，显示WebView布局。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用FrameLayout简单一些，两种方法都是需要对WebChromeClient的onProgressChanged进行监听，加载完毕进行页面切换，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  webView.setWebChromeClient(new WebChromeClient() {
        @Override
        public void onProgressChanged(WebView view, int newProgress) {
            super.onProgressChanged(view, newProgress);
            if (newProgress &amp;gt;= 100) {
                // 切换页面
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过以上几步的优化，一个流畅的webapp生成了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 17 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/17/android-webview-optimize/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/17/android-webview-optimize/</guid>
        
        <category>android</category>
        
        <category>network</category>
        
        
      </item>
    
      <item>
        <title>给jekyll添加炫酷简洁的搜索</title>
        <description>&lt;p&gt;试试&lt;strong&gt;双击Ctrl键&lt;/strong&gt;看看，或者点击&lt;strong&gt;右下角搜索图标&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;博客从wordpress的jekyll，jekyll的核心思想:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;将纯文本转化为静态网站和博客
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。&lt;/p&gt;

&lt;p&gt;jekyll没有数据库支持，默认没有搜索功能，那么怎么添加炫酷简洁的搜索的功能呢？google一下，大部分都是使用插件之类的，起始我们可以直接在服务端产生索引，之后利用索引进行搜索。&lt;/p&gt;

&lt;p&gt;受到spotlight的简洁启发，在目前小胖轩导航栏上已经没有空间了，于是打算做出一个类似于spotlight的搜索。下面先看一下操作步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;① 服务端生成文章索引
② 浏览器获取文章索引
③ 页面交互以及按键控制
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;服务器生成文章索引&quot;&gt;服务器生成文章索引&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;---
layout: null
---
{
	&quot;code&quot; : 0 ,
	&quot;data&quot; : [
	 {\% for post in site.posts \%}
	{
		&quot;title&quot; : &quot; - {\% for tag in post.tags \%}{\% if forloop.rindex != 1 \%}_{\% else \%}{\% endif \%}{\% endfor \%}&quot;,
		&quot;url&quot; : &quot;&quot;
	}
	{\% if forloop.rindex != 1  \%}
	,
	{\% endif \%}
    {\% endfor \%}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;由于文章中的动态代码会被解析，所以做了替换，代码中%被替换成\%,使用中请去除%前面的转义符&lt;/li&gt;
    &lt;li&gt;liquid语言对行敏感，如果需要把2个字符串拼接一起，那么字符串必须在同一行，否则字符串间将加入回车符&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段代码是一个双层循环，将文章的标题与标签组合，同时和url一起组合为json字符串，方便后续ajax调用。&lt;/p&gt;

&lt;h3 id=&quot;浏览器获取文章索引&quot;&gt;浏览器获取文章索引&lt;/h3&gt;

&lt;p&gt;此处也即一个ajax调用，使用$.ajax或者$.getJson都可以，此处可以参考一下ajax的异步请求。&lt;/p&gt;

&lt;h3 id=&quot;页面交互以及按键控制&quot;&gt;页面交互以及按键控制&lt;/h3&gt;

&lt;p&gt;为了能够有一个更好的交互，对搜索进行了很多的按键的操作:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PC下双击Ctrl键打开或者关闭搜索框&lt;/li&gt;
  &lt;li&gt;搜索框展示时按下Esc键关闭搜索框&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按键的检测在js中也是很容易进行，此处也不在列代码了。&lt;/p&gt;

&lt;p&gt;为了移动端也可以很好的搜索，在页面的右下角加入搜索悬浮按钮，点击后打开搜索页面，而在搜索页面，右上角提供关闭按钮，这样整体下来就完美的实现了搜索。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 11 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/11/jekyll-search/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/11/jekyll-search/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>a+=b 等价于 a=a+b ?</title>
        <description>&lt;p&gt;&lt;strong&gt;a += b&lt;/strong&gt;和&lt;strong&gt;a = a + b&lt;/strong&gt;完全等价么(java)？可能很多人以为是一样的，其实并非等价的，下面看一下证据吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        int a = 0;
        float c = 2.0f;
        a += c;
        a = a +  c;  //①
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码有问题么？ 能够通过编译么？ 答案是&lt;strong&gt;否定的&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ javac Test.java
Test.java:6: error: possible loss of precision
         a = a +  c;
               ^
  required: int
  found:    float
1 error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现的问题是编译错误， 但是&lt;strong&gt;a += c&lt;/strong&gt;却不会出现编译错误，能够正常通过编译。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么为这样呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将&lt;strong&gt;①&lt;/strong&gt;处代码去除后，顺利编译，可以使用jd-gui等工具看一下&lt;strong&gt;a += c&lt;/strong&gt;的反编译后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test
{
  public static void main(String[] paramArrayOfString)
  {
    int i = 0;
    float f = 2.0F;
    i = (int)(i + f);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看一下以下这句:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; i = (int)(i + f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;strong&gt;a += c&lt;/strong&gt;在编译的时候做了强制类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;结论: 
对于 a += c
如果a的类型可以兼容b，则 (a += c) 等价于 (a = a + c) 
否则，则会在a与c做完加法后进行强制转换。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 10 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/10/java-operate/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/10/java-operate/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>图片灰度化</title>
        <description>&lt;p&gt;怎么将图片灰度化，看到一个黑白滤镜的实现，黑白滤镜原理十分简单,是根据各种颜色在人眼中的亮度响应将rgb三通道的像素转换成单通道的灰度像素.而对于彩色转灰度,有一个很著名的心理学公式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Gray = R*0.299 + G*0.587 + B*0.114 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面看一下具体怎么使用，怎么讲一张彩色照片转变为黑白照片。看一段java代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.lyd.image;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

/**
 * Created by yuedong on 7/2/15.
 */
public class GrayImage {
    public static void main(String[] args) throws IOException {
        File file = new File(&quot;src.png&quot;);
        File out = new File(&quot;out.png&quot;);
        BufferedImage image = ImageIO.read(file);
        int width = image.getWidth();
        int height = image.getHeight();
        for (int i = 0; i &amp;lt; width; i++) {
            for (int j = 0; j &amp;lt; height; j++) {
                int rgb = image.getRGB(i, j);
                int r = rgb &amp;amp; 0x00ff0000 &amp;gt;&amp;gt; 16;
                int g = rgb &amp;amp; 0x0000ff00 &amp;gt;&amp;gt; 8;
                int b = rgb &amp;amp; 0x000000ff;

        //根据公式计算
        int color = (int) (r * 0.299 + g * 0.587 + b * 0.114);
        image.setRGB(i, j, new Color(color, color, color).getRGB());
        }
    }
    ImageIO.write(image, &quot;PNG&quot;, out);

    //rgb相同下产生的图片
    BufferedImage colorImage = new BufferedImage(256, 256 * 3, BufferedImage.TYPE_3BYTE_BGR);
    for (int i = 0; i &amp;lt; 256; i++) {
        for (int j = 0; j &amp;lt; 256 * 3; j++) {
            int k = j/3;
            colorImage.setRGB(i,j,new Color(k,k,k).getRGB());
        }
    }

    File colorFile = new File(&quot;color.png&quot;);
    ImageIO.write(colorImage, &quot;PNG&quot;, colorFile);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码进行了2个操作，一个讲图片进行灰度化，怎么进行灰度化呢，可以看出，仅仅是获取每一个点的rgb值，按照公式计算出灰度值，然后设置新的rgb值，每一个r,g,b的值都是这个灰度值。处理前后的照片如下:
&lt;img src=&quot;/img/image-src.png&quot; alt=&quot;img&quot; /&gt;
&lt;img src=&quot;/img/image-gray.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么呢？因为r=g=b时，获取的颜色的区间就是由黑到白，紧接着的代码就是将r=g=b的颜色绘制出来，图片如下(最上面的是r=g=b=0,最下面的是r=g=b=255):
&lt;img src=&quot;/img/image-rgb.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 02 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/07/02/image-gray/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/07/02/image-gray/</guid>
        
        <category>java</category>
        
        <category>discover</category>
        
        
      </item>
    
      <item>
        <title>Android Handler如何避免内存泄露</title>
        <description>&lt;p&gt;在使用Android Handler的时候，可能会遇到编译器给我们这样的警告:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This Handler class should be static or leaks might occur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;造成这个警告的原因是handler持有外层类(Activity等)的引用,同时消息队列中的Message对handler也持有引用，这样就造成一些资源不能回，从而可能造成内存泄露。&lt;/p&gt;

&lt;p&gt;解决这个警告的办法即让handler不持有外部类的引用，怎么做到这一点呢，即将Handler设置为静态内部类就行了，将外部类(Activity等)传递给Handler，在Handler中建立弱引用(WeakReference)。&lt;/p&gt;

&lt;p&gt;为了能够使以后更好的使用Handler-Message机制，我这里对其进行了封装，使用方法见下。先看一下代码。&lt;/p&gt;

&lt;h3 id=&quot;cbhandlerjava&quot;&gt;CBHandler.java&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package me.codeboy.android.common.component;

import android.os.Handler;
import android.os.Message;

import java.lang.ref.WeakReference;

import me.codeboy.android.common.app.CBActivity;

/**
 * Created by yuedong.lyd on 6/7/15.
 * &amp;lt;p&amp;gt;;
 *    构建防止内存泄露的handler
 * &amp;lt;/p&amp;gt;
 */
public class CBHandler {
    /**
     * 防止handler对activity有隐式引用，匿名内部类不会对外部类有引用
     */
   public static class UnleakHandler extends Handler {
        private final WeakReference&amp;lt;CBActivity&amp;gt; activity;

        public UnleakHandler(CBActivity activity) {
            this.activity =  new WeakReference&amp;amp;lt;CBActivity&amp;amp;gt;(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            if(activity.get() == null) {
                return;
            }
            activity.get().processMessage(msg);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cbactivity&quot;&gt;CBActivity&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.android.common.app;

import android.app.Activity;
import android.os.Bundle;
import android.os.Message;

import me.codeboy.android.common.component.CBHandler;

/**
 * Created by yuedong.lyd on 6/8/15.
 */
public abstract  class CBActivity extends Activity{
    public CBHandler.UnleakHandler handler ;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        handler = new CBHandler.UnleakHandler(this);
    }

    /**
     * 处理消息
     * @param msg
     */
    public abstract void processMessage(Message msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用中，我们只需自己的Activity继承CBActivity即可，在onCreate时自动创建UnleakHandler的实例handler,从CBHandler的代码中我们也可以看出来，UnleakHandler自动将收到的消息交给CBActivity中的processMessage进行处理。我们只需要在发送消息的时候使用handler变量发送即可，处理在processHandler中处理即可。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 28 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/06/28/android-unleak-hander/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/28/android-unleak-hander/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Context, What Context?</title>
        <description>&lt;p&gt;Android中有各种各样的context，不同context有不同的用途，不仅仅生命周期不同，同时能够实现的操作也不相同，下面看一篇外国朋友总结的文章:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Context is probably the most used element in Android application, it may also be the most misused.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Context objects are so common, and get passed around so frequently, it can be easy to create a situation you didn’t intend.  Loading resources, launching a new Activity, obtaining a system service, getting internal file paths, and creating views all require a Context (and that’s not even getting started on the full list!) to accomplish the task.  What I’d like to do is provide for you some insights on how Context works alongside some tips that will (hopefully) allow you to leverage it more effectively in your applications.&lt;/p&gt;

&lt;h2 id=&quot;context-types&quot;&gt;Context Types&lt;/h2&gt;
&lt;p&gt;Not all Context instances are created equal.  Depending on the Android application component, the Contextyou have access to varies slightly:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Application&lt;/strong&gt; – is a singleton instance running in your application process.  It can be accessed via methods like getApplication() from an Activity or Service, and getApplicationContext() from any other object that inherits from Context.  Regardless of where or how it is accessed, you will always receive the same instance from within your process.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Activity/Service&lt;/strong&gt; – inherit from ContextWrapper which implements the same API, but proxies all of its method calls to a hidden internal Context instance, also known as its base context.  Whenever the framework creates a new Activity or Service instance, it also creates a new ContextImpl instance to do all of the heavy lifting that either component will wrap.  Each Activity or Service, and their corresponding base context, are unique per-instance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BroadcastReceiver&lt;/strong&gt; – is not a Context in and of itself, but the framework passes a Context to it in onReceive() each time a new broadcast event comes in.  This instance is a ReceiverRestrictedContext with two main functions disabled; calling registerReceiver() and bindService().  These two functions are not allowed from within an existing BroadcastReceiver.onReceive().  Each time a receiver processes a broadcast, the Contexthanded to it is a new instance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ContentProvider&lt;/strong&gt; – is also not a Context but is given one when created that can be accessed via getContext().  If the ContentProvider is running local to the caller (i.e. same application process), then this will actually return the same Application singleton.  However, if the two are in separate processes, this will be a newly created instance representing the package the provider is running in.&lt;/p&gt;

&lt;h2 id=&quot;saved-references&quot;&gt;Saved References&lt;/h2&gt;
&lt;p&gt;The first issue we need to address comes from saving a reference to a Context in an object or class that has a lifecycle that extends beyond that of the instance you saved.  For example, creating a custom singleton that requires a Context to load resources or access a ContentProvider, and saving a reference to the current Activity or Service in that singleton.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bad Singleton&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CustomManager {
    private static CustomManager sInstance;
 
    public static CustomManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new CustomManager(context);
        }
 
        return sInstance;
    }
 
    private Context mContext;
 
    private CustomManager(Context context) {
        mContext = context;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is we don’t know where that Context came from, and it is not safe to hold a reference to the object if it ends up being an Activity or a Service.  This is a problem because a singleton is managed by a single static reference inside the enclosing class.  This means that our object, and ALL the other objects referenced by it, will never be garbage collected.  If this Context were an Activity, we would effectively hold hostage in memory all the views and other potentially large objects associated with it; creating a leak.&lt;/p&gt;

&lt;p&gt;To protect against this, we modify the singleton to always reference the application context:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Better Singleton&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CustomManager {
    private static CustomManager sInstance;
 
    public static CustomManager getInstance(Context context) {
        if (sInstance == null) {
            //Always pass in the Application Context
            sInstance = new CustomManager(context.getApplicationContext());
        }
 
        return sInstance;
    }
 
    private Context mContext;
 
    private CustomManager(Context context) {
        mContext = context;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it doesn’t matter where our Context came from, because the reference we are holding is safe.  The application context is itself a singleton, so we aren’t leaking anything by creating another static reference to it.  Another great example of places where this can crop up is saving references to a Context from inside a running background thread or a pending Handler.&lt;/p&gt;

&lt;p&gt;So why can’t we always just reference the application context?  Take the middleman out of the equation, as it were, and never have to worry about creating leaks?  The answer, as I alluded to in the introduction, is because one Context is not equal to another.&lt;/p&gt;

&lt;h2 id=&quot;context-capabilities&quot;&gt;Context Capabilities&lt;/h2&gt;
&lt;p&gt;The common actions you can safely take with a given Context object depends on where it came from originally.  Below is a table of the common places an application will receive a Context, and in each case what it is useful for:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;FUNCTION&lt;/th&gt;
      &lt;th&gt;APPLICATION&lt;/th&gt;
      &lt;th&gt;ACTIVITY&lt;/th&gt;
      &lt;th&gt;SERVICE&lt;/th&gt;
      &lt;th&gt;CONTENTPROVIDER&lt;/th&gt;
      &lt;th&gt;BROADCASTRECEIVER&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Show a Dialog&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Start an Activity&lt;/td&gt;
      &lt;td&gt;NO①&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO①&lt;/td&gt;
      &lt;td&gt;NO①&lt;/td&gt;
      &lt;td&gt;NO①&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Layout Inflation&lt;/td&gt;
      &lt;td&gt;NO②&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO②&lt;/td&gt;
      &lt;td&gt;NO②&lt;/td&gt;
      &lt;td&gt;NO②&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Start a Service&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bind to a Service&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Send a Broadcast&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Register BroadcastReceiver&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO③&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Load Resource Values&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;① An application CAN start an Activity from here, but it requires that a new task be created.  This may fit specific use cases, but can create non-standard back stack behaviors in your application and is generally not recommended or considered good practice.&lt;/p&gt;

  &lt;p&gt;② This is legal, but inflation will be done with the default theme for the system on which you are running, not what’s defined in your application.&lt;/p&gt;

  &lt;p&gt;③ Allowed if the receiver is null, which is used for obtaining the current value of a sticky broadcast, on Android 4.2 and above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;user-interface&quot;&gt;User Interface&lt;/h2&gt;
&lt;p&gt;You can see from looking at the previous table that there are a number of functions the application context is not properly suited to handle; all of them related to working with the UI.  In fact, the only implementation equipped to handle all tasks associated with the UI is Activity; the other instances fare pretty much the same in all categories.&lt;/p&gt;

&lt;p&gt;Luckily, these three actions are things an application doesn’t really have any place doing outside the scope of an Activity; it’s almost like the framework was designed that way on purpose.  Attempting to show a Dialogthat was created with a reference to the application context, or starting an Activity from the application context will throw an exception and crash your application…a strong indicator something has gone wrong.&lt;/p&gt;

&lt;p&gt;The less obvious issue is inflating layouts.  If you read my last piece on layout inflation, you already know that it can be a slightly mysterious process with some hidden behaviors;  using the right Context is linked to another one of those behaviors.  While the framework will not complain and will return a perfectly good view hierarchy from a LayoutInflater created with the application context, the themes and styles from your app will not be considered in the process.  This is because Activity is the only Context on which the themes defined in your manifest are actually attached.  Any other instance will use the system default theme to inflate your views, leading to a display output you probably didn’t expect.&lt;/p&gt;

&lt;h2 id=&quot;the-intersection-of-these-rules&quot;&gt;The Intersection of these Rules&lt;/h2&gt;

&lt;p&gt;Invariably, someone will arrive at the conclusion that these two rules conflict.  There is a case in the application’s current design where a long-term reference must be saved and we must save an Activity because the tasks we want to accomplish include manipulation of the UI.  If that is the case, I would urge you to reconsider your design, as this would be a textbook instance of fighting the framework.&lt;/p&gt;

&lt;h2 id=&quot;the-rule-of-thumb&quot;&gt;The Rule of Thumb&lt;/h2&gt;
&lt;p&gt;In most cases, use the Context directly available to you from the enclosing component you’re working within.  You can safely hold a reference to it as long as that reference does not extend beyond the lifecycle of that component. As soon as you need to save a reference to a Context from an object that lives beyond your Activity or Service, even temporarily, switch that reference you save over to the application context.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;转自: https://possiblemobile.com/2013/06/context/&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 28 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/06/28/android-context/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/06/28/android-context/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title> Js实现旋转的图片</title>
        <description>&lt;p&gt;gif可以实现旋转的图片，但是怎么使用js实现的。自己想了一下，打算实现一下，整体思路也很简单，每隔一段时间，旋转一下图片，看起来就像在一直旋转一样。&lt;a href=&quot;http://example.codeboy.me/rotate/&quot;&gt;实例地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;旋转rotate.js的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by YD on 5/7/15.
 * Base on Jquery
 */
var ele ;

//自定义函数
$.fn.extend({
	rotate: function () {
	ele = this ;
	setInterval('singleRotate()',20);
   }
});

//初始角度
var degree = 0;

//单次旋转
function singleRotate() {
	//一次增加50度
	degree = degree + 50 * Math.PI / 180;
	ele.css(&quot;transform&quot;,&quot;rotate(&quot;+degree+&quot;deg)&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中只需引用一下js就行了，我将其封装后放在了服务器上，大家可以直接引用&lt;/p&gt;

&lt;p&gt;引用前记得引用jquery，最后在自己的代码中调用rotate方法即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(element).rotate();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 08 May 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/05/08/js-rorate-image/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/05/08/js-rorate-image/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>Android Ndk的应用</title>
        <description>&lt;p&gt;做android开发，或多或少应该对ndk有些了解。大家都知道，开发android应用很多部分是使用java完成的，但是java语言使用起来虽然简单，但是也比较容易进行反编译，尽管现在网络上有很多的加密工具。那怎么保护应用的一些隐私逻辑模块(加解密)的，ndk是一个很好的选择。&lt;/p&gt;

&lt;p&gt;ndk使用c或者cpp完成代码的编写，使用c或者cpp可以将一些模块编译为链接库(so文件)，这些文件反编译起来则非常的困难，同时使用c和cpp写出的代码在执行效率上会有所提升。本文将展示使用ndk技术将字符串的简单加解密方法写进so文件中。&lt;/p&gt;

&lt;p&gt;考虑到编码等的原因，本文中的加密解密算法方式为：java中将字符串转为为byte数组，然后通过jni调用c语言加解密函数，同时将byte数据传递给c(中间有一部类型转化，将byte数组转化为char数组)，c语言对char数组进行加解密后返回。有关ndk的一些简单使用，大家可以看一些麦子学院的&lt;a href=&quot;http://www.maiziedu.com/lesson/3805/&quot;&gt;教程&lt;/a&gt;,本文中只对使用的一些例子进行解释。对于字符串的加解密，按照本文的方式加解密应该是一种不错的方式，使用中您可能需要修改一下c语言中的加解密函数即可。&lt;/p&gt;

&lt;p&gt;本文中c语言对char数组的加解密很简单，对每一个char进行拆分，char占8位，高4位与低4位拆成2个数值，然后根据数值从一个长度为16的钥匙串中拿出对应字符，这些字符对应的数组记为加密后的字符串。反向解密原理相似，只需要将字符数组中每2个字符抽取，计算出加密前的数值即可。下面看一下整体ndk的使用。&lt;/p&gt;

&lt;p&gt;使用ndk前，需要从android官网上下载ndk组件，解压后大概3G左右，建议一个新项目(AndroidNDK)，将新项目目录指定在ndk解压后的根目录(这样比较方便，不这样做也可以)，我们需要在新项目中额外添加的只有一个jni目录，jni目录与src，res等是同一层的。目录内需要含有的文件如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mac:AndroidNDK YD$ tree  jni
jni
├── Android.mk
├── Application.mk
└── encrypt.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中encrypt.c即是我们的加解密函数所在的位置，Android.mk与Application.mk为配置文件，内容很固定。可以看下各个文件的内容:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Application.mk&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;APP_ABI := armeabi,armeabi-v7a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Application.mk中还有其他的一些配置，大家可以去官网或者google一下，常用的配置是App_ABI,指定生成对应cpu架构的库文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android.mk&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := codeboy_encrypt
LOCAL_SRC_FILES := encrypt.c
LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog
include $(BUILD_SHARED_LIBRARY)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Android.mk中需要修改的内容只有LOCAL_MODULE和LOCAL_SRC_FILES,前者指定生成的连接库名称，后者指定要编译的c语言或者cpp的文件名字，其他的保持不变即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;encrypt.c&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include&amp;lt;string.h&amp;gt;
#include&amp;lt;jni.h&amp;gt;
#include&amp;lt;android/log.h&amp;gt;

//宏定义打印函数,使用方法 LOGI(&quot;hello&quot;) 或者 LOGI(&quot;money %d&quot;,15)
#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, &quot;native&quot;, __VA_ARGS__))
#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, &quot;native&quot;, __VA_ARGS__))

const char key[] = &quot;abcdefghijklmnop&quot;; //16个字符
int len = 0;

//计算字符对应的byte值
unsigned char getByteNumber(unsigned char first, unsigned char end) {
    int firstPosition = 0, endPosition = 0;
    int position = 0;
    for (; position &amp;lt; 16; position++) {
        if (key[position] == first) {
            firstPosition = position;
        }
        if (key[position] == end) {
            endPosition = position;
        }
    }
    return (firstPosition &amp;lt;&amp;lt; 4) | (endPosition);
}

//加密函数
void encrypt(unsigned char p[], unsigned char res[]) {
    int i = 0;
    for (; i &amp;lt; len; i++) {
        res[2 * i] = key[p[i] / 16];
        res[2 * i + 1] = key[p[i] % 16];
    }
}

//解密函数
void decrypt(unsigned char p[], char res[]) {
    int i;
    for (i = 0; i &amp;lt; len; i++) {
        res[i] = getByteNumber(p[i * 2], p[i * 2 + 1]);
    }
}

//java中生命的native函数，函数名称格式Java_包名(点换下划线)_类名_函数名
//前两个参数JNIEnv *env, jclass this比较固定，其中第二个参数jclass代表方法是静态的，仅仅是个表示，如果方法不是静态的话，jclass换成jobject
//后续的参数是函数要传进来的参数
//java中的byte数组对应jni中的jbyteArray,jni中的jbyteArray可以通过jni中的函数转换为char数组
jstring Java_me_codeboy_encrypt_EncryptUtil_encrypt(JNIEnv *env, jclass this,
        jbyteArray src) {
    unsigned char *buff = (char*) (*env)-&amp;gt;GetByteArrayElements(env, src, NULL);
    len = (*env)-&amp;gt;GetArrayLength(env, src);
    //加密后长度变为原先的2倍
    unsigned char res[len * 2];
    encrypt(buff, res);
    //此步骤很重要，标志结束
    res[len * 2] = '\0';

    //使用完毕释放src数组，因为src数组的存在jvm中
    (*env)-&amp;gt;ReleaseByteArrayElements(env, src, buff, 0);

    //jni中函数将char数组转变为字符串，jni中字符串为jstring，对应java中的String
    jstring resStr = (*env)-&amp;gt;NewStringUTF(env, res);
    return resStr;
}

//和加密类似
jstring Java_me_codeboy_encrypt_EncryptUtil_decrypt(JNIEnv *env, jclass this,
        jbyteArray src) {
    unsigned char *buff = (char*) (*env)-&amp;gt;GetByteArrayElements(env, src, NULL);
    len = (*env)-&amp;gt;GetArrayLength(env, src);
    //解密后长度变为原先的1/2
    len = len / 2;
    signed char res[len];
    decrypt(buff, res);
    //此步骤很重要，标志结束
    res[len] = '\0';

    //使用完毕释放src数组，因为src数组的存在jvm中
    (*env)-&amp;gt;ReleaseByteArrayElements(env, src, buff, 0);

    jstring resStr = (*env)-&amp;gt;NewStringUTF(env, res);
    return resStr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们的ndk相关的文件就写好了，下面在终端下切换到AndroidNDK目录下,运行命令即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;../ndk-build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mac:AndroidNDK YD$ ../ndk-build
Android NDK: WARNING: APP_PLATFORM android-21 is larger than android:minSdkVersion 14 in ./AndroidManifest.xml    
[armeabi] Compile thumb  : codeboy_encrypt &amp;lt;= encrypt.c
[armeabi] SharedLibrary  : libcodeboy_encrypt.so
[armeabi] Install        : libcodeboy_encrypt.so =&amp;gt; libs/armeabi/libcodeboy_encrypt.so
[armeabi-v7a] Compile thumb  : codeboy_encrypt &amp;lt;= encrypt.c
[armeabi-v7a] SharedLibrary  : libcodeboy_encrypt.so
[armeabi-v7a] Install        : libcodeboy_encrypt.so =&amp;gt; libs/armeabi-v7a/libcodeboy_encrypt.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完成后，我们可以看一下libs文件夹,多了一些so文件,如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mac:AndroidNDK YD$ tree libs
libs
├── android-support-v4.jar
├── armeabi
│   └── libcodeboy_encrypt.so
└── armeabi-v7a
    └── libcodeboy_encrypt.so

2 directories, 3 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们就开始写对应的java代码了，将调用c函数的加解密函数抽象到一个类中即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EncryptUtil.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.encrypt;

public class EncryptUtil {
    public native static String encrypt(byte[] src); // 加密函数

    public native static String decrypt(byte[] src); // 解密函数

    static {
        System.loadLibrary(&quot;codeboy_encrypt&quot;);
    }

    /**
     * 加密函数
     * 
     * @param src
     * @return
     */
    public static String encrypt(String src) {
        return encrypt(src.getBytes());
    }

    /**
     * 解密函数
     * 
     * @param src
     * @return
     */
    public static String decrypt(String src) {
        return decrypt(src.getBytes());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意C语言中的函数名称中的包名类名函数名要与该类统一，还有对应的链接库名称。&lt;/p&gt;

&lt;p&gt;做好了这些以后，我们就可以使用了。在我们的Activity中简单的定义一个按钮，点击后对一个字符串进行加密打印，之后进行解密打印，Activity中的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.ndk.ui;

import me.codeboy.encrypt.EncryptUtil;
import me.codeboy.ndk.R;
import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        setContentView(R.layout.main_ui);
        super.onCreate(savedInstanceState);

        Button btn = (Button) findViewById(R.id.btn);
        btn.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                String src = &quot;我是玄恒，欢迎访问我的网站codeboy.me&quot;;
                String res = EncryptUtil.encrypt(src);
                System.out.println(&quot;------&amp;gt;&quot; + res);
                res = EncryptUtil.decrypt(res);
                System.out.println(&quot;---&amp;gt;&quot; + res);
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击按钮后可以看到点击button打印的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---&amp;gt;ogiijbogjikpohioieogibjcoplmimogkmkcoilpiooikolpojjhkoogiijbohjkieohlnjbohkljjgdgpgegfgcgphjcogngf
---&amp;gt;我是玄恒，欢迎访问我的网站codeboy.me
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样下来我们就完成了简单的加解密操作,也对ndk有了一个初步的了解。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 04 May 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/05/04/android-ndk/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/05/04/android-ndk/</guid>
        
        <category>android</category>
        
        
      </item>
    
  </channel>
</rss>
